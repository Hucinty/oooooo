<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realtime Sketch Converter - 15 Effects (Rotated 180°)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b1220; --card:#0f1724; --muted:#9aa6b2; --accent:#60a5fa;
    }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;background:var(--bg);color:#e6eef6;display:flex;min-height:100vh;align-items:center;justify-content:center;padding:18px;}
    .app{width:100%;max-width:1100px;background:linear-gradient(180deg,#071026 0%, #071622 100%);border-radius:12px;padding:18px;box-shadow:0 10px 30px rgba(2,6,23,.6);}
    h1{margin:0 0 12px 0;font-size:20px}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:16px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:8px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
    canvas{width:100%;height:auto;border-radius:6px;background:#000;display:block;}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center}
    button{background:var(--accent);border:none;color:#022;padding:8px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    button.red{background:#fb7185;color:#111}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    select,input[type="range"],input[type="color"]{width:100%}
    .status{font-size:13px;color:var(--muted);margin-top:10px}
    .small{font-size:13px;color:var(--muted)}
    .footer{font-size:12px;color:var(--muted);margin-top:12px}
    .row { display:flex; gap:10px; align-items:center; }
    .col { display:flex; flex-direction:column; gap:6px; }
  </style>
</head>
<body>
  <div class="app">
    <h1>Realtime Sketch Converter — 15 Minimal/Tint Effects (Rotated 180°)</h1>
    <div class="grid">
      <div class="card">
        <canvas id="glcanvas" width="960" height="540"></canvas>

        <div class="controls" style="margin-top:12px;">
          <button id="startBtn">Start Camera</button>
          <button id="toggleCam" class="ghost" disabled>Switch Camera</button>
          <button id="stopBtn" class="red" disabled>Stop Camera</button>
          <button id="snapshotBtn" class="ghost">Snapshot</button>
          <button id="startRecBtn">Start Recording</button>
          <button id="stopRecBtn" class="red" disabled>Stop Recording</button>
          <a id="downloadRec" class="ghost" style="display:none" download="sketch_record.webm">Download Recording</a>
        </div>

        <div style="display:flex;gap:12px;margin-top:10px;">
          <div style="flex:1">
            <label for="filterSelect">Filter</label>
            <select id="filterSelect">
              <option value="minimalPencil">0 - Minimal Pencil</option>
              <option value="pencilInk">1 - Pencil Ink</option>
              <option value="warmSepia">2 - Warm Sepia Pencil</option>
              <option value="coolBlue">3 - Cool Blue Pencil</option>
              <option value="duotoneRB">4 - Duotone (Red/Blue)</option>
              <option value="softPastel">5 - Soft Pastel</option>
              <option value="posterInk">6 - Poster Ink</option>
              <option value="charcoal">7 - Charcoal</option>
              <option value="colorSplash">8 - Color Splash</option>
              <option value="heatmap">9 - Heatmap Pencil</option>
              <option value="highKey">10 - High-Key Ink</option>
              <option value="original">11 - Original</option>
              <option value="invert">12 - Invert</option>
              <option value="posterize">13 - Posterize</option>
              <option value="neon">14 - Neon Glow</option>
            </select>
          </div>
          <div style="width:220px">
            <label for="sensitivity">Edge Sensitivity</label>
            <input id="sensitivity" type="range" min="0.2" max="4" step="0.01" value="1.5">
          </div>
        </div>

        <div style="display:flex;gap:12px;margin-top:10px;align-items:center">
          <div style="width:120px">
            <label for="tintPicker">Tint</label>
            <input id="tintPicker" type="color" value="#bfb9b0">
          </div>
          <div style="width:160px">
            <label for="levels">Posterize Levels</label>
            <input id="levels" type="range" min="2" max="8" step="1" value="4">
          </div>
        </div>

        <div class="status" id="status">Status: idle</div>
        <div class="footer">Tip: Serve over HTTP (e.g. python -m http.server). Use Chrome/Edge for best WebGL + recording support.</div>
      </div>

      <div class="card">
        <h3 style="margin-top:0">Internal / Debug</h3>
        <div class="small">Video size: <span id="vsize">—</span></div>
        <div class="small">WebGL: <span id="glinfo">—</span></div>
        <hr style="opacity:.06;margin:12px 0">
        <div>
          <label>Recording MIME</label>
          <div class="small" id="mimeInfo">—</div>
        </div>

        <hr style="opacity:.06;margin:12px 0">
        <div>
          <label>Recorded clip</label>
          <video id="playback" controls style="width:100%;border-radius:6px;margin-top:8px;display:none"></video>
        </div>
      </div>
    </div>

    <!-- Hidden video + fallback canvas -->
    <video id="video" autoplay playsinline muted style="display:none"></video>
    <canvas id="fallbackCanvas" width="960" height="540" style="display:none"></canvas>
  </div>

<script>
let useFront = true; // true = front camera, false = back camera
let useFront = true; // track camera side
/*
  poi.html - Realtime Sketch Converter
  - 15 effects in WebGL (fast)
  - 180° rotation applied to texture coords in shader (camera rotated)
  - CPU fallback implements simplified versions
*/

const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const snapshotBtn = document.getElementById('snapshotBtn');
const startRecBtn = document.getElementById('startRecBtn');
const stopRecBtn = document.getElementById('stopRecBtn');
const downloadRec = document.getElementById('downloadRec');
const filterSelect = document.getElementById('filterSelect');
const sensitivity = document.getElementById('sensitivity');
const statusEl = document.getElementById('status');
const vsizeEl = document.getElementById('vsize');
const glinfoEl = document.getElementById('glinfo');
const mimeInfo = document.getElementById('mimeInfo');
const playbackEl = document.getElementById('playback');

const tintPicker = document.getElementById('tintPicker');
const levelsSlider = document.getElementById('levels');

const video = document.getElementById('video');
const glCanvas = document.getElementById('glcanvas');
const fallbackCanvas = document.getElementById('fallbackCanvas');

let mediaStream = null;
let audioStream = null;
let animationId = null;
let gl = null;
let programInfo = null;
let texture = null;
let videoReady = false;
let usingWebGL = false;

// recording
let mediaRecorder = null;
let recordedChunks = [];
let recordedUrl = null;

function logStatus(msg){
  statusEl.textContent = 'Status: ' + msg;
}

function detectMime(){
  const candidates = [
    'video/webm;codecs=vp9,opus',
    'video/webm;codecs=vp8,opus',
    'video/webm;codecs=h264,opus',
    'video/webm',
    'video/mp4'
  ];
  for(const c of candidates){
    if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)){
      return c;
    }
  }
  return 'video/webm';
}
mimeInfo.textContent = detectMime();

async function startCamera(){
  if (mediaStream) return;
  logStatus('requesting camera...');
  try {
    if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
    if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); mediaStream = null; }
    mediaStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: useFront ? "user" : "environment", width: 1280, height: 720 },
      audio: false
    });
    video.srcObject = mediaStream;
    await video.play();
    videoReady = true;
    vsizeEl.textContent = video.videoWidth + ' x ' + video.videoHeight;
    logStatus('camera running');
    document.getElementById("toggleCam").disabled = false;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    document.getElementById("toggleCam").disabled = false;

    initWebGLIfPossible();
    startRenderLoop();
  } catch (err){
    console.error(err);
    alert('Could not access camera: ' + err.message);
    logStatus('camera error');
  }
}

function stopCamera(){
  if (mediaStream){
    mediaStream.getTracks().forEach(t => t.stop());
    mediaStream = null;
  }
  video.pause();
  video.srcObject = null;
  videoReady = false;
  cancelAnimationFrame(animationId);
  animationId = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
    document.getElementById("toggleCam").disabled = true;
  logStatus('stopped');
}

// ---------- WebGL (GLSL) ----------
const vsSource = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;
void main(){
  v_texCoord = a_texCoord;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

// Fragment shader implementing many minimal-color / pencil/ink effects.
// u_mode maps to effects listed in UI (0..14). Shader flips UVs for 180° rotation.
const fsSource = `#version 300 es
precision highp float;
in vec2 v_texCoord;
out vec4 outColor;
uniform sampler2D u_texture;
uniform vec2 u_texel;
uniform float u_sensitivity;
uniform int u_mode;
uniform vec3 u_tint;
uniform float u_levels;

float lum(vec3 c){ return dot(c, vec3(0.299,0.587,0.114)); }
vec3 posterize(vec3 c, float levels){ return floor(c * levels) / (levels - 1.0); }
vec3 heatmap(vec3 x){
  float v = x.r; // single channel assumed
  return vec3(clamp(v*2.0,0.0,1.0), clamp((v*2.0-0.5)*1.2,0.0,1.0), clamp(1.0 - v*1.2,0.0,1.0));
}
void main(){
  // rotate 180 degrees by flipping coords
  vec2 uv = vec2(1.0 - v_texCoord.x, 1.0 - v_texCoord.y);
  vec3 c = texture(u_texture, uv).rgb;

  // quick passthrough modes
  if(u_mode == 11){
    outColor = vec4(c,1.0); return;
  }
  if(u_mode == 12){
    outColor = vec4(1.0 - c,1.0); return;
  }
  if(u_mode == 13){
    outColor = vec4(posterize(c, u_levels),1.0); return;
  }

  // sample luminance neighborhood for edges (Sobel)
  float tl = lum(texture(u_texture, uv + vec2(-u_texel.x, -u_texel.y)).rgb);
  float  t = lum(texture(u_texture, uv + vec2(0.0, -u_texel.y)).rgb);
  float tr = lum(texture(u_texture, uv + vec2(u_texel.x, -u_texel.y)).rgb);
  float l  = lum(texture(u_texture, uv + vec2(-u_texel.x, 0.0)).rgb);
  float m  = lum(texture(u_texture, uv).rgb);
  float r  = lum(texture(u_texture, uv + vec2(u_texel.x, 0.0)).rgb);
  float bl = lum(texture(u_texture, uv + vec2(-u_texel.x, u_texel.y)).rgb);
  float b  = lum(texture(u_texture, uv + vec2(0.0, u_texel.y)).rgb);
  float br = lum(texture(u_texture, uv + vec2(u_texel.x, u_texel.y)).rgb);

  float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
  float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;
  float mag = sqrt(gx*gx + gy*gy);

  // edge mask (0..1) where 0 = strong black edge, 1 = no edge
  float edge = 1.0 - clamp(mag * u_sensitivity, 0.0, 1.0);

  // Modes
  if(u_mode == 0){
    // Minimal Pencil: quantize gray, tint, overlay dark edges
    float g = lum(c);
    float q = floor(g * u_levels) / max(1.0, (u_levels - 1.0));
    vec3 base = mix(vec3(q), u_tint, 0.45);
    float e = 1.0 - pow(edge, 1.0);
    vec3 finalCol = base * 0.7 + vec3(e) * 0.95;
    outColor = vec4(finalCol,1.0);
    return;
  }

  if(u_mode == 1){
    // Pencil Ink: white base, dark crisp edges
    float g = lum(c);
    float e = 1.0 - clamp(mag * u_sensitivity * 1.8, 0.0, 1.0);
    vec3 final = mix(vec3(1.0), vec3(0.0), e);
    outColor = vec4(final,1.0);
    return;
  }

  if(u_mode == 2){
    // Warm Sepia Pencil
    float g = lum(c);
    float q = floor(g * u_levels) / max(1.0, (u_levels - 1.0));
    vec3 sep = mix(vec3(q), vec3(0.85,0.7,0.55), 0.55);
    float e = 1.0 - clamp(mag * u_sensitivity * 1.3, 0.0, 1.0);
    outColor = vec4(sep * 0.75 + vec3(1.0 - e) * 0.8,1.0);
    return;
  }

  if(u_mode == 3){
    // Cool Blue Pencil
    float g = lum(c);
    float q = floor(g * u_levels) / max(1.0, (u_levels - 1.0));
    vec3 blu = mix(vec3(q), vec3(0.6,0.75,0.95), 0.55);
    float e = 1.0 - clamp(mag * u_sensitivity * 1.3, 0.0, 1.0);
    outColor = vec4(blu * 0.75 + vec3(1.0 - e) * 0.85,1.0);
    return;
  }

  if(u_mode == 4){
    // Duotone Red/Blue
    float g = lum(c);
    float q = floor(g * u_levels) / max(1.0, (u_levels - 1.0));
    vec3 dark = vec3(0.11,0.08,0.2);
    vec3 light = vec3(0.9,0.4,0.5);
    outColor = vec4(mix(light, dark, q),1.0);
    return;
  }

  if(u_mode == 5){
    // Soft Pastel - muted base + gentle edges
    vec3 p = posterize(c, u_levels);
    float e = 1.0 - clamp(mag * u_sensitivity * 0.9, 0.0, 1.0);
    outColor = vec4(p * 0.9 + vec3(1.0 - e) * 0.35,1.0);
    return;
  }

  if(u_mode == 6){
    // Poster Ink - thick black strokes + strong posterization
    vec3 p = posterize(c, max(2.0,u_levels));
    float e = 1.0 - clamp(mag * u_sensitivity * 2.0, 0.0, 1.0);
    outColor = vec4(mix(p, vec3(0.0), 1.0 - e),1.0);
    return;
  }

  if(u_mode == 7){
    // Charcoal - dark grainy
    float g = lum(c);
    float q = floor(g * u_levels) / max(1.0,(u_levels - 1.0));
    float e = 1.0 - clamp(mag * u_sensitivity * 1.6, 0.0, 1.0);
    vec3 charcoal = vec3(q*0.5) * 0.6 + vec3(1.0-e)*1.0;
    outColor = vec4(charcoal,1.0);
    return;
  }

  if(u_mode == 8){
    // Color Splash - keep tint color where hue close, rest minimal
    float g = lum(c);
    vec3 hsvApprox = c; // cheap heuristic
    float keep = step(0.45, c.r); // naive: keep red-ish areas (fallback)
    vec3 base = mix(vec3(g), u_tint, 0.5);
    outColor = vec4(mix(base, c, keep),1.0);
    return;
  }

  if(u_mode == 9){
    // Heatmap Pencil - heatmap colorized base with edges
    float g = lum(c);
    vec3 hm = heatmap(vec3(g));
    float e = 1.0 - clamp(mag * u_sensitivity * 1.2, 0.0, 1.0);
    outColor = vec4(hm * 0.7 + vec3(1.0 - e) * 0.9,1.0);
    return;
  }

  if(u_mode == 10){
    // High-Key Ink - white background, thin edges
    float e = 1.0 - clamp(mag * u_sensitivity * 2.4, 0.0, 1.0);
    vec3 final = mix(vec3(1.0), vec3(0.0), e*0.9);
    outColor = vec4(final,1.0);
    return;
  }

  if(u_mode == 14){
    // Neon Glow: uplift colors and add glow from edges
    vec3 p = posterize(c, max(3.0,u_levels));
    float e = 1.0 - clamp(mag * u_sensitivity * 2.0, 0.0, 1.0);
    vec3 glow = p + vec3(1.0 - e) * 0.8;
    outColor = vec4(glow,1.0);
    return;
  }

  // fallback
  outColor = vec4(c,1.0);
}
`;

// helpers to create GL program
function createShader(gl, type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error('Shader compile error:', gl.getShaderInfoLog(s));
    gl.deleteShader(s);
    return null;
  }
  return s;
}

function createProgram(gl, vsSrc, fsSrc){
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  if (!vs || !fs) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error('Program link error:', gl.getProgramInfoLog(prog));
    gl.deleteProgram(prog);
    return null;
  }
  return prog;
}

function initWebGLIfPossible(){
  try {
    gl = glCanvas.getContext('webgl2', {preserveDrawingBuffer:true}) || glCanvas.getContext('webgl', {preserveDrawingBuffer:true});
    if (!gl) {
      usingWebGL = false;
      glinfoEl.textContent = 'WebGL not supported; using 2D canvas fallback';
      return;
    }
    usingWebGL = true;
    glinfoEl.textContent = 'WebGL enabled (' + (gl instanceof WebGL2RenderingContext ? 'WebGL2' : 'WebGL1') + ')';
    const program = createProgram(gl, vsSource, fsSource);
    if (!program){
      usingWebGL = false;
      glinfoEl.textContent = 'Shader compile failed; falling back';
      return;
    }
    gl.useProgram(program);

    const posLoc = gl.getAttribLocation(program, 'a_position');
    const texLoc = gl.getAttribLocation(program, 'a_texCoord');

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const verts = new Float32Array([
      -1, -1,  0, 1,
       1, -1,  1, 1,
      -1,  1,  0, 0,
      -1,  1,  0, 0,
       1, -1,  1, 1,
       1,  1,  1, 0
    ]);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(texLoc);
    gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 16, 8);

    const texUniform = gl.getUniformLocation(program, 'u_texture');
    const texelUniform = gl.getUniformLocation(program, 'u_texel');
    const sensUniform = gl.getUniformLocation(program, 'u_sensitivity');
    const modeUniform = gl.getUniformLocation(program, 'u_mode');
    const tintUniform = gl.getUniformLocation(program, 'u_tint');
    const levelsUniform = gl.getUniformLocation(program, 'u_levels');

    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    programInfo = {
      program, vao,
      uniforms: { texUniform, texelUniform, sensUniform, modeUniform, tintUniform, levelsUniform }
    };
  } catch (err){
    console.warn('WebGL init error', err);
    usingWebGL = false;
    glinfoEl.textContent = 'WebGL init error; fallback to 2D';
  }
}

// Main render loop
function startRenderLoop(){
  cancelAnimationFrame(animationId);
  function render(){
    if (!videoReady) return;
    const w = video.videoWidth || 640;
    const h = video.videoHeight || 480;

    if (glCanvas.width !== w || glCanvas.height !== h){
      glCanvas.width = w; glCanvas.height = h;
      fallbackCanvas.width = w; fallbackCanvas.height = h;
      if (gl && programInfo){
        gl.viewport(0,0,w,h);
      }
    }

    const mode = filterSelect.value;
    const sens = parseFloat(sensitivity.value);
    const levels = parseFloat(levelsSlider.value);

    if (usingWebGL && gl && programInfo){
      gl.useProgram(programInfo.program);
      gl.bindVertexArray(programInfo.vao);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      try {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);
      } catch(e){
        usingWebGL = false;
        glinfoEl.textContent = 'WebGL texImage error; switching fallback';
      }

      const texel = [1.0 / Math.max(1, w), 1.0 / Math.max(1, h)];
      gl.uniform1i(programInfo.uniforms.texUniform, 0);
      gl.uniform2fv(programInfo.uniforms.texelUniform, texel);
      gl.uniform1f(programInfo.uniforms.sensUniform, sens);

      const modeMap = {
        'minimalPencil':0,'pencilInk':1,'warmSepia':2,'coolBlue':3,'duotoneRB':4,'softPastel':5,
        'posterInk':6,'charcoal':7,'colorSplash':8,'heatmap':9,'highKey':10,'original':11,'invert':12,'posterize':13,'neon':14
      };
      const modeInt = modeMap[mode] || 0;
      gl.uniform1i(programInfo.uniforms.modeUniform, modeInt);

      // tint
      const tint = hexToRgbNorm(tintPicker.value);
      gl.uniform3fv(programInfo.uniforms.tintUniform, tint);

      gl.uniform1f(programInfo.uniforms.levelsUniform, Math.max(2.0, levels));

      gl.drawArrays(gl.TRIANGLES, 0, 6);
    } else {
      // CPU fallback: simplified implementations for many modes
      const ctx = fallbackCanvas.getContext('2d');
      ctx.drawImage(video, 0, 0, w, h);
      const src = ctx.getImageData(0,0,w,h);
      const outCtx = glCanvas.getContext('2d');
      const d = src.data;

      const lvl = Math.max(2, parseInt(levelsSlider.value,10));
      const tint = hexToRgb(tintPicker.value);
      // precompute grayscale
      const gray = new Float32Array(w*h);
      for(let i=0, p=0;i<d.length;i+=4,p++){
        gray[p] = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      }
      // sobel edges
      const edge = new Float32Array(w*h);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const i = y*w + x;
          const a = gray[i - w - 1], b = gray[i - w], c = gray[i - w + 1];
          const l = gray[i - 1], r = gray[i + 1];
          const bl = gray[i + w - 1], bb = gray[i + w], br = gray[i + w + 1];
          const gx = -a - 2*l - bl + c + 2*r + br;
          const gy = -a - 2*b - c + bl + 2*bb + br;
          edge[i] = Math.hypot(gx,gy);
        }
      }

      // Helper to quantize
      function quant(val, levels){
        return Math.floor(val * (levels) / 255) * (255/(levels-1));
      }

      // Process modes (simplified)
      for(let y=0, idx=0;y<h;y++){
        for(let x=0;x<w;x++, idx++){
          const p = idx*4;
          const g = gray[idx];
          const e = edge[idx] || 0;
          const ed = 1 - Math.min(1, e * (parseFloat(sensitivity.value) * 0.02));
          let r=0,gc=0,b=0;
          switch(mode){
            case 'original':
              // nothing to change (we'll blit later)
              r = d[p]; gc = d[p+1]; b = d[p+2]; break;
            case 'invert':
              r = 255 - d[p]; gc = 255 - d[p+1]; b = 255 - d[p+2]; break;
            case 'posterize':
              r = quant(d[p], lvl); gc = quant(d[p+1], lvl); b = quant(d[p+2], lvl); break;
            case 'pencilInk':
              {
                const E = 1 - clamp(e * (sensitivity.value*0.02),0,1);
                const v = E * 0; // black edge
                r = gc = b = (1 - E) * 255;
              } break;
            case 'warmSepia':
              {
                const q = quant(g, lvl);
                r = Math.min(255, q*0.85 + 60);
                gc = Math.min(255, q*0.7 + 40);
                b = Math.min(255, q*0.55 + 20);
                const blend = ed; r = r * 0.8 + (1-ed)*255*0.2;
              } break;
            case 'coolBlue':
              {
                const q = quant(g, lvl);
                r = q*0.6; gc = q*0.75; b = q*0.95;
                r = Math.min(255,r); gc=Math.min(255,gc); b=Math.min(255,b);
                r = r*0.8 + (1-ed)*255*0.2;
              } break;
            case 'duotoneRB':
              {
                const q = quant(g,lvl)/255;
                const dark = [28,20,51];
                const light= [230,100,140];
                r = light[0]*(1-q)+dark[0]*q;
                gc= light[1]*(1-q)+dark[1]*q;
                b = light[2]*(1-q)+dark[2]*q;
              } break;
            case 'softPastel':
              {
                const q = quant(g,lvl);
                r = q*0.9 + 30; gc = q*0.95 + 30; b = q*0.9 + 35;
              } break;
            case 'posterInk':
              {
                const q = quant(g,lvl);
                const E = 1 - Math.min(1, e * (sensitivity.value*0.03));
                r = gc = b = q * (1 - E);
              } break;
            case 'charcoal':
              {
                const q = quant(g,lvl);
                r = gc = b = q*0.6 + (1-ed)*255*0.4;
              } break;
            case 'colorSplash':
              {
                // keep tint hue approx: check red channel > others
                if (d[p] > d[p+1] && d[p] > d[p+2]){ r = d[p]; gc = d[p+1]; b = d[p+2]; }
                else { r = gc = b = g; }
              } break;
            case 'heatmap':
              {
                const q = quant(g,lvl)/255;
                const hm = heatmapCPU(q);
                r = hm.r; gc = hm.g; b = hm.b;
              } break;
            case 'highKey':
              {
                const E = 1 - Math.min(1, e * (sensitivity.value*0.04));
                r = gc = b = 255 * (1 - 0.9*E);
              } break;
            case 'minimalPencil':
            default:
              {
                // minimal pencil fallback
                const q = quant(g,lvl)/255;
                const baseR = q * tint.r;
                const baseG = q * tint.g;
                const baseB = q * tint.b;
                const finalR = Math.min(255, (baseR * 0.75 + ed*255*0.95));
                const finalG = Math.min(255, (baseG * 0.75 + ed*255*0.95));
                const finalB = Math.min(255, (baseB * 0.75 + ed*255*0.95));
                r = finalR; gc = finalG; b = finalB;
              } break;
          }
          d[p] = clamp(r,0,255);
          d[p+1] = clamp(gc,0,255);
          d[p+2] = clamp(b,0,255);
          d[p+3] = 255;
        }
      }
      outCtx.putImageData(src,0,0);
    }

    animationId = requestAnimationFrame(render);
  }
  render();
}

// small helper functions used in CPU path
function clamp(x,a,b){ return Math.min(b, Math.max(a, x)); }
function heatmapCPU(v){ // v in [0,1]
  return { r: clamp(255 * Math.min(1, v*2.0),0,255), g: clamp(255 * Math.max(0, (v*2.0-0.5)*1.2),0,255), b: clamp(255 * (1.0 - v*1.2),0,255) };
}

// ---------- Snapshot ----------
snapshotBtn.addEventListener('click', () => {
  const dataUrl = glCanvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = 'sketch_' + Date.now() + '.png';
  document.body.appendChild(a);
  a.click();
  a.remove();
});

// ---------- Recording (canvas + mic) ----------
startRecBtn.addEventListener('click', async () => {
  if (!videoReady){
    alert('Start the camera first');
    return;
  }
  try {
    logStatus('requesting microphone...');
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
  } catch (err){
    console.warn('No mic or permission denied:', err);
    if (!confirm('Microphone access failed or denied. Record without audio?')) return;
    audioStream = null;
  }

  const canvasStream = glCanvas.captureStream(30);
  const tracks = [];
  canvasStream.getVideoTracks().forEach(t => tracks.push(t));
  if (audioStream) audioStream.getAudioTracks().forEach(t => tracks.push(t));
  const combined = new MediaStream(tracks);

  const mime = detectMimeTypeForRecorder();
  let options = mime ? { mimeType: mime } : undefined;
  try {
    mediaRecorder = new MediaRecorder(combined, options);
  } catch (err){
    console.error('MediaRecorder error', err);
    alert('Recording not supported in this browser/config.');
    return;
  }
  recordedChunks = [];
  mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: mime || 'video/webm' });
    if (recordedUrl) URL.revokeObjectURL(recordedUrl);
    recordedUrl = URL.createObjectURL(blob);
    downloadRec.href = recordedUrl;
    downloadRec.style.display = 'inline-block';
    downloadRec.download = 'sketch_record_' + Date.now() + '.webm';
    playbackEl.src = recordedUrl;
    playbackEl.style.display = 'block';
  };

  mediaRecorder.start();
  startRecBtn.disabled = true;
  stopRecBtn.disabled = false;
  logStatus('recording...');
});

stopRecBtn.addEventListener('click', () => {
  if (!mediaRecorder) return;
  mediaRecorder.stop();
  mediaRecorder = null;
  if (audioStream){ audioStream.getTracks().forEach(t => t.stop()); audioStream = null; }
  startRecBtn.disabled = false;
  stopRecBtn.disabled = true;
  logStatus('recording stopped');
});

downloadRec.addEventListener('click', () => {
  setTimeout(() => {}, 5000);
});

function detectMimeTypeForRecorder(){
  const candidates = [
    'video/webm;codecs=vp9,opus',
    'video/webm;codecs=vp8,opus',
    'video/webm',
    'video/mp4'
  ];
  for (const c of candidates){
    if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c;
  }
  return 'video/webm';
}

// UI wiring
startBtn.addEventListener('click', startCamera);
stopBtn.addEventListener('click', stopCamera);

const toggleCam = document.getElementById('toggleCam');
toggleCam.addEventListener('click', async () => {
  useFront = !useFront;
  await startCamera();
});


filterSelect.addEventListener('change', () => { /* handled in render */ });
sensitivity.addEventListener('input', () => { /* handled in render */ });
levelsSlider.addEventListener('input', () => { /* handled in render */ });

// util - hex color to normalized rgb
function hexToRgb(hex){
  hex = hex.replace('#','');
  const bigint = parseInt(hex, 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return { r,g,b };
}
function hexToRgbNorm(hex){
  const c = hexToRgb(hex);
  return [c.r/255, c.g/255, c.b/255];
}

// ensure cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
  if (audioStream) audioStream.getTracks().forEach(t=>t.stop());
  if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
});

</script>
</body>
</html>
